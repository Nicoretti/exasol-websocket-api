{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Exasol WebSockets API","text":"<p> Info</p> <p>Please note that this is an open source project which is officially supported by Exasol. For any question, you can contact our support team.</p>"},{"location":"#why-a-websockets-api","title":"Why a WebSockets API?","text":"<p>The JSON over WebSockets client-server protocol allows customers to  implement their own drivers for all kinds of platforms using a  connection-based web protocol. </p> <p>The main advantages are performance improvements from lock-free metadata calls, flexibility regarding the programming languages  you want to integrate Exasol into, and a more native access compared to  the standardized ways of communicating with a database, such as JDBC,  ODBC or ADO.NET, which are mostly old and static standards and create additional complexity due to the necessary driver managers.</p>"},{"location":"#client-support","title":"Client support","text":"<p>Currently a native Python driver using this WebSocket API has been implemented. By that you don't need any pyodbc bridge anymore, but  can connect your Python directly with Exasol. PyODBC is not ideal due to the need for an ODBC driver manager and certain restrictions in  data type conversions.</p> <p>Further languages will be added in the future, and we encourage you to provide us feedback what languages you are interested in, and  maybe you are even keen to support our community with own developments.  It would then be nice if you could share your work with us, and  we will of course help you by any means. </p>"},{"location":"#changes","title":"Changes","text":"<ul> <li>Autocommit was enabled by default for sessions in Exasol 7.1+.</li> <li>WebSocket API v3 support has been added in Exasol 7.1.</li> <li>WebSocket API v2 support has been added in Exasol 7.0.</li> </ul>"},{"location":"#supported-versions","title":"Supported versions","text":"WebSocket API v1 WebSocket API v2 WebSocket API v3 Exasol 7.1 Exasol 7.0 Exasol 6.2"},{"location":"#protocol-specifications","title":"Protocol Specifications","text":"<ul> <li>WebSocket protocol v3 API specification</li> <li>WebSocket protocol v2 API specification</li> <li>WebSocket protocol v1 API specification</li> </ul>"},{"location":"#officially-supported-implementations","title":"Officially Supported Implementations","text":""},{"location":"#python","title":"Python","text":"<ul> <li>exasol-websocket-api</li> <li>Pyexasol</li> </ul>"},{"location":"#javascript","title":"Javascript","text":"<ul> <li>exasol-websocket-api</li> </ul>"},{"location":"#go","title":"Go","text":"<ul> <li>Go native driver implementation</li> </ul>"},{"location":"WebsocketAPIV1/","title":"WebsocketAPIV1","text":""},{"location":"WebsocketAPIV1/#websocket-protocol-v1-details","title":"WebSocket protocol v1 details","text":"<p>WebSocket Protocol v1 requires an Exasol version of at least 6.0.0. It follows the RFC 6455 document of the IETF.</p> <p>The Exasol connection server identifies the initial GET request by the client. This request contains information about the used protocol version. Depending on this information the matching login and protocol class is chosen.</p> <p>After the handshake the process is identical to a connection using the standard drivers like JDBC or ODBC: The connection server listens to incoming messages and forwards the requests to the database. </p>"},{"location":"WebsocketAPIV1/#table-of-contents","title":"Table of contents","text":"<ul> <li>Changes</li> <li>Command summary</li> <li>Attributes: Session and database properties</li> <li>Data Types: Type names and properties</li> <li>Compression</li> <li>Heartbeat/Feedback messages</li> <li>Subconnections</li> </ul>"},{"location":"WebsocketAPIV1/#changes","title":"Changes","text":"Date Exasol Version Change Issue 2021.06.22 7.1.0 Autocommit was enabled by default for sessions in Exasol 7.1+. See Attributes for details.Autocommit can be disabled in order to restore the previous behavior. Please see the driver's documentation on how to do this. EXASOL-2908 2020.03.10 7.0.0 Columns of type <code>HASHTYPE</code> must be specified using the <code>CHAR</code> type. EXASOL-2643 2020.01.16 6.2.56.1.9 For compatibility reasons, WebSocket logins with a protocol version higher than supported versions will be accepted but automatically downgraded to the latest supported version. EXASOL-2614"},{"location":"WebsocketAPIV1/#command-summary","title":"Command summary","text":""},{"location":"WebsocketAPIV1/#connection-related-commands","title":"Connection-related commands","text":"<p>The following commands are used to connect to Exasol, disconnect from Exasol,  and query the hosts of an Exasol cluster.</p> Command Description disconnect Closes a connection to Exasol enterParallel Opens subconnections for parallel execution getHosts Gets the hosts in a cluster login Establishes a connection to Exasol subLogin Establishes a subconnection to Exasol"},{"location":"WebsocketAPIV1/#session-related-commands","title":"Session-related commands","text":"<p>The following commands are used for actions that a user would typically perform after an Exasol  session has been established. These commands are responsible for executing queries and statements,  reading result sets, and getting and setting session attributes.</p> Command Description abortQuery Aborts a running query closePreparedStatement Closes a prepared statement closeResultSet Closes a result set createPreparedStatement Creates a prepared statement execute Executes an SQL statement executeBatch Executes multiple SQL statements as a batch executePreparedStatement Executes a prepared statement fetch Retrieves data from a result set getAttributes Gets the session attribute values getOffset Gets the row offset of a result set getResultSetHeader Gets a result set header setAttributes Sets the given session attribute values"},{"location":"WebsocketAPIV1/#attributes-session-and-database-properties","title":"Attributes: Session and database properties","text":"<p>Attributes can be queried with the getAttributes command and some of them can be modified with the setAttributes command. Modified attributes are included in command replies.</p> Name JSON value Read-only Committable Description autocommit true | false no no If true, commit() will be executed automatically after each statement. If false, commit() and rollback() must be executed manually. compressionEnabled true | false yes no If true, the WebSocket data frame payload data is compressed. If false, it is not compressed. currentSchema string no yes Current schema name dateFormat string yes yes Date format dateLanguage string yes yes Language used for the day and month of dates. datetimeFormat string yes yes Timestamp format defaultLikeEscapeCharacter string yes yes Escape character in LIKE expressions. feedbackInterval number no no Time interval (in seconds) specifying how often heartbeat/feedback packets are sent to the client during query execution. numericCharacters string no yes Characters specifying the group and decimal separators (NLS_NUMERIC_CHARACTERS). For example, \",.\" would result in \"123,456,789.123\". openTransaction true | false yes no If true, a transaction is open. If false, a transaction is not open. queryTimeout number no yes Query timeout value (in seconds). If a query runs longer than the specified time, it will be aborted. snapshotTransactionsEnabled true | false no no If true, snapshot transactions will be used. If false, they will not be used. timestampUtcEnabled true | false no no If true, timestamps will be converted to UTC. If false, UTC will not be used. timezone string yes yes Timezone of the session. timeZoneBehavior string yes yes Specifies the conversion behavior of UTC timestamps to local timestamps when the time value occurs during a time shift because of daylight saving time (TIME_ZONE_BEHAVIOR). <p>Attributes are specified as an object of name/value pairs. Multiple attributes are separated by a comma.</p> <p>Attribute JSON format <pre><code> {\n// name: value\n&lt;string&gt;: &lt;string | number | true | false&gt;\n}\n</code></pre></p>"},{"location":"WebsocketAPIV1/#data-types-type-names-and-properties","title":"Data Types: Type names and properties","text":"<p>The following data types and properties can be used to specify column types in the executePreparedStatement request.</p> Type Required Properties Optional Properties BOOLEAN CHAR size DATE DECIMAL precision, scale DOUBLE GEOMETRY INTERVAL DAY TO SECOND precision, fraction INTERVAL YEAR TO MONTH precision TIMESTAMP withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE withLocalTimeZone VARCHAR size <p>The following data types and properties are used to specify column types in responses from Exasol.</p> Type Properties BOOLEAN CHAR size, characterSet DATE size DECIMAL precision, scale DOUBLE GEOMETRY size, srid INTERVAL DAY TO SECOND size, precision, fraction INTERVAL YEAR TO MONTH size, precision TIMESTAMP size, withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE size, withLocalTimeZone VARCHAR size, characterSet"},{"location":"WebsocketAPIV1/#compression","title":"Compression","text":"<p>The data in the WebSocket data frames may be compressed using zlib. In order to enable compression, the client must set the <code>useCompression</code> field in the login command to true. If compression is enabled during login, all messages sent and received after login completion must be binary data frames, in which the payload data (i.e., command request/response) is zlib-compressed.</p>"},{"location":"WebsocketAPIV1/#heartbeatfeedback-messages","title":"Heartbeat/Feedback messages","text":"<p>The <code>feedbackInterval</code> session attribute specifies how often (in seconds) unidirectional heartbeat/feedback messages are sent to the client during query execution. These messages are sent using Pong WebSocket control frames (see RFC 6455), and thus a response is not expected.</p> <p>The client may send Ping WebSocket control frames (see RFC 6455) to Exasol, for example, as client-initiated keepalives. Exasol will respond to a Ping frame with a Pong response.</p> <p>Exasol will not send Ping frames to the client.</p>"},{"location":"WebsocketAPIV1/#subconnections","title":"Subconnections","text":""},{"location":"WebsocketAPIV1/#introduction","title":"Introduction","text":"<p>Subconnections are additional connections to Exasol cluster nodes which can be created by the client. There are two main reasons to create and use subconnections. 1. Read a result set in parallel: fetch can be called in parallel by each of the subconnections to read a result set. 2. <code>INSERT</code> data in parallel: executePreparedStatement can be called in parallel on each of the subconnections to <code>INSERT</code> various data. Please note that the same prepared statement (see createPreparedStatement) must be executed on all subconnections.</p> <p>\u2139\ufe0f Here, parallel refers to the node-wise reading/inserting of data. For example, if there is a subconnection for each node (i.e., the number of subconnections equals the number of cluster nodes), then each subconnection will read/insert data locally from/into its node.</p> <p>Fetching a result set from Exasol can be done easily using the main connection. In this scenario, the Exasol cluster nodes will automatically send their data to the node which is connected to the client. This node then sends the combined data as a single result set. Thus, the client does not need to be aware of any data sharing/communication among the Exasol cluster nodes.</p> <p>However, for performance-critical scenarios, a significant performance gain can be acheived by using subconnections to fetch/insert data directly from/into multiple Exasol cluster nodes in parallel. Thus, instead of all the data going through the single main connection, the data can flow through multiple subconnections from/to different Exasol nodes in parallel.</p> <p>Please note that subconnections are only useful for multi-node Exasol clusters. With a single-node Exasol instance, the subconnection would basically be a duplicate of the main connection.</p>"},{"location":"WebsocketAPIV1/#how-to-create-and-use-subconnections","title":"How to create and use subconnections","text":"<p>Subconnections are created using the enterParallel command. The number of requested subconnections can be specified by the user, and the number of subconnections actually opened is given in the enterParallel response. Please note that the maximum number of subconnections is equal to the number of nodes in the Exasol cluster. For example, if the user has an eight-node cluster and requests 1,000 subconnections, only eight subconnections will be opened. As a general rule, the number of subconnections should usually be equal to the number of nodes in the Exasol cluster, which ensures one subconnection per node. After the subconnections have been created, the subLogin command should be used to login to each subconnection. Note: Failing to login to all subconnections will cause the login to hang. After this, they are ready for use.</p> <p>\u26a0\ufe0f Please note: autocommit should be disabled before opening any subconnections. After closing the subconnections, it can be re-enabled.</p> <p>Any command can be executed on subconnections; however, there is a significant difference in how they can be executed. The only two commands which can be executed ansynchronously on subconnections (i.e., not executed on all subconnections at the same time) are fetch and executePreparedStatement. All other commands are synchronous, meaning the same command must be executed on all subconnections at the same time. For example, if the execute command is not called on all subconnections, the call will hang and eventually fail because of a time out.</p> <p>\u26a0\ufe0f Please note: different statements cannot be run in parallel using subconnections.</p> <p>After a subconnection is no longer needed, the disconnect command should be called and the WebSocket for it closed as normal. Please note that subconnections can be reused for multiple statements.</p>"},{"location":"WebsocketAPIV1/#example","title":"Example","text":"<p>The following is an example of how to create, use, and close subconnections to fetch a result set from an executed prepared statement. If subconnections have already been created or are needed afterwards, the enterParallel, subLogin, and disconnect commands may be ignored.</p> <ol> <li>On main connection:</li> <li> <p>Create subconnections (enterParallel)</p> </li> <li> <p>On subconnections:</p> </li> <li> <p>Login to subconnection (subLogin)</p> </li> <li> <p>On main connection:</p> </li> <li> <p>Execute prepared statement (executePreparedStatement)</p> </li> <li> <p>On subconnections:</p> </li> <li>Get result set offset (getOffset)</li> <li>Fetch result set data using the offset (fetch)</li> <li>Close result set (closeResultSet)</li> <li> <p>Disconnect (disconnect)</p> </li> <li> <p>On main connection:</p> </li> <li>Close result set (closeResultSet)</li> </ol>"},{"location":"WebsocketAPIV2/","title":"WebsocketAPIV2","text":""},{"location":"WebsocketAPIV2/#websocket-protocol-v2-details","title":"WebSocket protocol v2 details","text":"<p>WebSocket Protocol v2 requires an Exasol version of at least 7.0.0. It follows the RFC 6455 document of the IETF.</p> <p>The Exasol connection server identifies the initial GET request by the client. This request contains information about the used protocol version. Depending on this information the matching login and protocol class is chosen.</p> <p>After the handshake the process is identical to a connection using the standard drivers like JDBC or ODBC: The connection server listens to incoming messages and forwards the requests to the database. </p>"},{"location":"WebsocketAPIV2/#table-of-contents","title":"Table of contents","text":"<ul> <li>Changes</li> <li>Command summary</li> <li>Attributes: Session and database properties</li> <li>Data Types: Type names and properties</li> <li>Compression</li> <li>Heartbeat/Feedback messages</li> <li>Subconnections</li> </ul>"},{"location":"WebsocketAPIV2/#changes","title":"Changes","text":"Date Exasol Version Change Issue 2021.06.22 7.1.0 Autocommit was enabled by default for sessions in Exasol 7.1+. See Attributes for details.Autocommit can be disabled in order to restore the previous behavior. Please see the driver's documentation on how to do this. EXASOL-2908 2020.08.13 7.0.0 The <code>resultSetMaxRows</code> attribute was added. See Attributes for details. EXASOL-2734 2020.05.05 7.0.0 Metadata commands were added. See Metadata-related commands for details. EXASOL-2640 2020.10.03 7.0.0 Columns of type <code>HASHTYPE</code> can be specified using the <code>HASHTYPE</code> type. See Data Types for details. EXASOL-2643"},{"location":"WebsocketAPIV2/#command-summary","title":"Command summary","text":""},{"location":"WebsocketAPIV2/#connection-related-commands","title":"Connection-related commands","text":"<p>The following commands are used to connect to Exasol, disconnect from Exasol,  and query the hosts of an Exasol cluster.</p> Command Description disconnect Closes a connection to Exasol enterParallel Opens subconnections for parallel execution getHosts Gets the hosts in a cluster login Establishes a connection to Exasol subLogin Establishes a subconnection to Exasol"},{"location":"WebsocketAPIV2/#session-related-commands","title":"Session-related commands","text":"<p>The following commands are used for actions that a user would typically perform after an Exasol  session has been established. These commands are responsible for executing queries and statements,  reading result sets, and getting and setting session attributes.</p> Command Description abortQuery Aborts a running query closePreparedStatement Closes a prepared statement closeResultSet Closes a result set createPreparedStatement Creates a prepared statement execute Executes an SQL statement executeBatch Executes multiple SQL statements as a batch executePreparedStatement Executes a prepared statement fetch Retrieves data from a result set getAttributes Gets the session attribute values getOffset Gets the row offset of a result set getResultSetHeader Gets a result set header setAttributes Sets the given session attribute values"},{"location":"WebsocketAPIV2/#metadata-related-commands","title":"Metadata-related commands","text":"<p>The following commands are used to query metadata in Exasol. The commands and their behavior are very similar to methods in the JDBC standard.</p> Command Description getColumnPrivileges Gets column privilege descriptions getColumns Gets column descriptions getConnections Gets connection descriptions getFunctions Gets function descriptions getKeywords Gets SQL keywords getPrimaryKeys Gets primary key descriptions getProperties Gets database properties getRoles Gets role descriptions getSchemas Gets schema descriptions getScripts Gets script descriptions getTablePrivileges Gets table privilege descriptions getTables Gets table descriptions getTableTypes Gets supported table types getTypeInfo Gets supported data types getUsers Gets user descriptions"},{"location":"WebsocketAPIV2/#attributes-session-and-database-properties","title":"Attributes: Session and database properties","text":"<p>Attributes can be queried with the getAttributes command and some of them can be modified with the setAttributes command. Modified attributes are included in command replies.</p> Name JSON value Read-only Committable Description autocommit true | false no no If true, commit() will be executed automatically after each statement. If false, commit() and rollback() must be executed manually. compressionEnabled true | false yes no If true, the WebSocket data frame payload data is compressed. If false, it is not compressed. currentSchema string no yes Current schema name dateFormat string yes yes Date format dateLanguage string yes yes Language used for the day and month of dates. datetimeFormat string yes yes Timestamp format defaultLikeEscapeCharacter string yes yes Escape character in LIKE expressions. feedbackInterval number no no Time interval (in seconds) specifying how often heartbeat/feedback packets are sent to the client during query execution. numericCharacters string no yes Characters specifying the group and decimal separators (NLS_NUMERIC_CHARACTERS). For example, \",.\" would result in \"123,456,789.123\". openTransaction true | false yes no If true, a transaction is open. If false, a transaction is not open. queryTimeout number no yes Query timeout value (in seconds). If a query runs longer than the specified time, it will be aborted. resultSetMaxRows number no no Maximum number of result set rows returned, 0 (default) means no limit. Only applicable to execute, executeBatch and executePreparedStatement. snapshotTransactionsEnabled true | false no no If true, snapshot transactions will be used. If false, they will not be used. timestampUtcEnabled true | false no no If true, timestamps will be converted to UTC. If false, UTC will not be used. timezone string yes yes Timezone of the session. timeZoneBehavior string yes yes Specifies the conversion behavior of UTC timestamps to local timestamps when the time value occurs during a time shift because of daylight saving time (TIME_ZONE_BEHAVIOR). <p>Attributes are specified as an object of name/value pairs. Multiple attributes are separated by a comma.</p> <p>Attribute JSON format <pre><code> {\n// name: value\n&lt;string&gt;: &lt;string | number | true | false&gt;\n}\n</code></pre></p>"},{"location":"WebsocketAPIV2/#data-types-type-names-and-properties","title":"Data Types: Type names and properties","text":"<p>The following data types and properties can be used to specify column types in the executePreparedStatement request.</p> Type Required Properties Optional Properties BOOLEAN CHAR size DATE DECIMAL precision, scale DOUBLE GEOMETRY HASHTYPE INTERVAL DAY TO SECOND precision, fraction INTERVAL YEAR TO MONTH precision TIMESTAMP withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE withLocalTimeZone VARCHAR size <p>The following data types and properties are used to specify column types in responses from Exasol.</p> Type Properties BOOLEAN CHAR size, characterSet DATE size DECIMAL precision, scale DOUBLE GEOMETRY size, srid HASHTYPE size INTERVAL DAY TO SECOND size, precision, fraction INTERVAL YEAR TO MONTH size, precision TIMESTAMP size, withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE size, withLocalTimeZone VARCHAR size, characterSet"},{"location":"WebsocketAPIV2/#compression","title":"Compression","text":"<p>The data in the WebSocket data frames may be compressed using zlib. In order to enable compression, the client must set the <code>useCompression</code> field in the login command to true. If compression is enabled during login, all messages sent and received after login completion must be binary data frames, in which the payload data (i.e., command request/response) is zlib-compressed.</p>"},{"location":"WebsocketAPIV2/#heartbeatfeedback-messages","title":"Heartbeat/Feedback messages","text":"<p>The <code>feedbackInterval</code> session attribute specifies how often (in seconds) unidirectional heartbeat/feedback messages are sent to the client during query execution. These messages are sent using Pong WebSocket control frames (see RFC 6455), and thus a response is not expected.</p> <p>The client may send Ping WebSocket control frames (see RFC 6455) to Exasol, for example, as client-initiated keepalives. Exasol will respond to a Ping frame with a Pong response.</p> <p>Exasol will not send Ping frames to the client.</p>"},{"location":"WebsocketAPIV2/#subconnections","title":"Subconnections","text":""},{"location":"WebsocketAPIV2/#introduction","title":"Introduction","text":"<p>Subconnections are additional connections to Exasol cluster nodes which can be created by the client. There are two main reasons to create and use subconnections. 1. Read a result set in parallel: fetch can be called in parallel by each of the subconnections to read a result set. 2. <code>INSERT</code> data in parallel: executePreparedStatement can be called in parallel on each of the subconnections to <code>INSERT</code> various data. Please note that the same prepared statement (see createPreparedStatement) must be executed on all subconnections.</p> <p>\u2139\ufe0f Here, parallel refers to the node-wise reading/inserting of data. For example, if there is a subconnection for each node (i.e., the number of subconnections equals the number of cluster nodes), then each subconnection will read/insert data locally from/into its node.</p> <p>Fetching a result set from Exasol can be done easily using the main connection. In this scenario, the Exasol cluster nodes will automatically send their data to the node which is connected to the client. This node then sends the combined data as a single result set. Thus, the client does not need to be aware of any data sharing/communication among the Exasol cluster nodes.</p> <p>However, for performance-critical scenarios, a significant performance gain can be acheived by using subconnections to fetch/insert data directly from/into multiple Exasol cluster nodes in parallel. Thus, instead of all the data going through the single main connection, the data can flow through multiple subconnections from/to different Exasol nodes in parallel.</p> <p>Please note that subconnections are only useful for multi-node Exasol clusters. With a single-node Exasol instance, the subconnection would basically be a duplicate of the main connection.</p>"},{"location":"WebsocketAPIV2/#how-to-create-and-use-subconnections","title":"How to create and use subconnections","text":"<p>Subconnections are created using the enterParallel command. The number of requested subconnections can be specified by the user, and the number of subconnections actually opened is given in the enterParallel response. Please note that the maximum number of subconnections is equal to the number of nodes in the Exasol cluster. For example, if the user has an eight-node cluster and requests 1,000 subconnections, only eight subconnections will be opened. As a general rule, the number of subconnections should usually be equal to the number of nodes in the Exasol cluster, which ensures one subconnection per node. After the subconnections have been created, the subLogin command should be used to login to each subconnection. Note: Failing to login to all subconnections will cause the login to hang. After this, they are ready for use.</p> <p>\u26a0\ufe0f Please note: autocommit should be disabled before opening any subconnections. After closing the subconnections, it can be re-enabled.</p> <p>Any command can be executed on subconnections; however, there is a significant difference in how they can be executed. The only two commands which can be executed ansynchronously on subconnections (i.e., not executed on all subconnections at the same time) are fetch and executePreparedStatement. All other commands are synchronous, meaning the same command must be executed on all subconnections at the same time. For example, if the execute command is not called on all subconnections, the call will hang and eventually fail because of a time out.</p> <p>\u26a0\ufe0f Please note: different statements cannot be run in parallel using subconnections.</p> <p>After a subconnection is no longer needed, the disconnect command should be called and the WebSocket for it closed as normal. Please note that subconnections can be reused for multiple statements.</p>"},{"location":"WebsocketAPIV2/#example","title":"Example","text":"<p>The following is an example of how to create, use, and close subconnections to fetch a result set from an executed prepared statement. If subconnections have already been created or are needed afterwards, the enterParallel, subLogin, and disconnect commands may be ignored.</p> <ol> <li>On main connection:</li> <li> <p>Create subconnections (enterParallel)</p> </li> <li> <p>On subconnections:</p> </li> <li> <p>Login to subconnection (subLogin)</p> </li> <li> <p>On main connection:</p> </li> <li> <p>Execute prepared statement (executePreparedStatement)</p> </li> <li> <p>On subconnections:</p> </li> <li>Get result set offset (getOffset)</li> <li>Fetch result set data using the offset (fetch)</li> <li>Close result set (closeResultSet)</li> <li> <p>Disconnect (disconnect)</p> </li> <li> <p>On main connection:</p> </li> <li>Close result set (closeResultSet)</li> </ol>"},{"location":"WebsocketAPIV3/","title":"WebsocketAPIV3","text":""},{"location":"WebsocketAPIV3/#websocket-protocol-v3-details","title":"WebSocket protocol v3 details","text":"<p>WebSocket Protocol v3 requires an Exasol version of at least 7.1.0. It follows the RFC 6455 document of the IETF.</p> <p>The Exasol connection server identifies the initial GET request by the client. This request contains information about the used protocol version. Depending on this information the matching login and protocol class is chosen.</p> <p>After the handshake the process is identical to a connection using the standard drivers like JDBC or ODBC: The connection server listens to incoming messages and forwards the requests to the database. </p>"},{"location":"WebsocketAPIV3/#table-of-contents","title":"Table of contents","text":"<ul> <li>Changes</li> <li>Command summary</li> <li>Attributes: Session and database properties</li> <li>Data Types: Type names and properties</li> <li>Compression</li> <li>Heartbeat/Feedback messages</li> <li>Subconnections</li> </ul>"},{"location":"WebsocketAPIV3/#changes","title":"Changes","text":"Date Exasol Version Change Issue 2021.06.22 7.1.0 Autocommit was enabled by default for sessions in Exasol 7.1+. See Attributes for details.Autocommit can be disabled in order to restore the previous behavior. Please see the driver's documentation on how to do this. EXASOL-2908 2021.05.18 7.1.0 OpenID Connect support was added as a login option. See loginToken and subLoginToken for details.To login using an OpenID refresh token in compatibility mode, see login and subLogin. EXASOL-2867"},{"location":"WebsocketAPIV3/#command-summary","title":"Command summary","text":""},{"location":"WebsocketAPIV3/#connection-related-commands","title":"Connection-related commands","text":"<p>The following commands are used to connect to Exasol, disconnect from Exasol,  and query the hosts of an Exasol cluster.</p> Command Description disconnect Closes a connection to Exasol enterParallel Opens subconnections for parallel execution getHosts Gets the hosts in a cluster login Establishes a connection to Exasol loginToken Establishes a connection to Exasol using an OpenID token subLogin Establishes a subconnection to Exasol subLoginToken Establishes a subconnection to Exasol using an OpenID token"},{"location":"WebsocketAPIV3/#session-related-commands","title":"Session-related commands","text":"<p>The following commands are used for actions that a user would typically perform after an Exasol  session has been established. These commands are responsible for executing queries and statements,  reading result sets, and getting and setting session attributes.</p> Command Description abortQuery Aborts a running query closePreparedStatement Closes a prepared statement closeResultSet Closes a result set createPreparedStatement Creates a prepared statement execute Executes an SQL statement executeBatch Executes multiple SQL statements as a batch executePreparedStatement Executes a prepared statement fetch Retrieves data from a result set getAttributes Gets the session attribute values getOffset Gets the row offset of a result set getResultSetHeader Gets a result set header setAttributes Sets the given session attribute values"},{"location":"WebsocketAPIV3/#metadata-related-commands","title":"Metadata-related commands","text":"<p>The following commands are used to query metadata in Exasol. The commands and their behavior are very similar to methods in the JDBC standard.</p> Command Description getColumnPrivileges Gets column privilege descriptions getColumns Gets column descriptions getConnections Gets connection descriptions getFunctions Gets function descriptions getKeywords Gets SQL keywords getPrimaryKeys Gets primary key descriptions getProperties Gets database properties getRoles Gets role descriptions getSchemas Gets schema descriptions getScripts Gets script descriptions getTablePrivileges Gets table privilege descriptions getTables Gets table descriptions getTableTypes Gets supported table types getTypeInfo Gets supported data types getUsers Gets user descriptions"},{"location":"WebsocketAPIV3/#attributes-session-and-database-properties","title":"Attributes: Session and database properties","text":"<p>Attributes can be queried with the getAttributes command and some of them can be modified with the setAttributes command. Modified attributes are included in command replies.</p> Name JSON value Read-only Committable Description autocommit true | false no no If true, commit() will be executed automatically after each statement. If false, commit() and rollback() must be executed manually. compressionEnabled true | false yes no If true, the WebSocket data frame payload data is compressed. If false, it is not compressed. currentSchema string no yes Current schema name dateFormat string yes yes Date format dateLanguage string yes yes Language used for the day and month of dates. datetimeFormat string yes yes Timestamp format defaultLikeEscapeCharacter string yes yes Escape character in LIKE expressions. feedbackInterval number no no Time interval (in seconds) specifying how often heartbeat/feedback packets are sent to the client during query execution. numericCharacters string no yes Characters specifying the group and decimal separators (NLS_NUMERIC_CHARACTERS). For example, \",.\" would result in \"123,456,789.123\". openTransaction true | false yes no If true, a transaction is open. If false, a transaction is not open. queryTimeout number no yes Query timeout value (in seconds). If a query runs longer than the specified time, it will be aborted. resultSetMaxRows number no no Maximum number of result set rows returned, 0 (default) means no limit. Only applicable to execute, executeBatch and executePreparedStatement. snapshotTransactionsEnabled true | false no no If true, snapshot transactions will be used. If false, they will not be used. timestampUtcEnabled true | false no no If true, timestamps will be converted to UTC. If false, UTC will not be used. timezone string yes yes Timezone of the session. timeZoneBehavior string yes yes Specifies the conversion behavior of UTC timestamps to local timestamps when the time value occurs during a time shift because of daylight saving time (TIME_ZONE_BEHAVIOR). <p>Attributes are specified as an object of name/value pairs. Multiple attributes are separated by a comma.</p> <p>Attribute JSON format <pre><code> {\n// name: value\n&lt;string&gt;: &lt;string | number | true | false&gt;\n}\n</code></pre></p>"},{"location":"WebsocketAPIV3/#data-types-type-names-and-properties","title":"Data Types: Type names and properties","text":"<p>The following data types and properties can be used to specify column types in the executePreparedStatement request.</p> Type Required Properties Optional Properties BOOLEAN CHAR size DATE DECIMAL precision, scale DOUBLE GEOMETRY HASHTYPE INTERVAL DAY TO SECOND precision, fraction INTERVAL YEAR TO MONTH precision TIMESTAMP withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE withLocalTimeZone VARCHAR size <p>The following data types and properties are used to specify column types in responses from Exasol.</p> Type Properties BOOLEAN CHAR size, characterSet DATE size DECIMAL precision, scale DOUBLE GEOMETRY size, srid HASHTYPE size INTERVAL DAY TO SECOND size, precision, fraction INTERVAL YEAR TO MONTH size, precision TIMESTAMP size, withLocalTimeZone TIMESTAMP WITH LOCAL TIME ZONE size, withLocalTimeZone VARCHAR size, characterSet"},{"location":"WebsocketAPIV3/#compression","title":"Compression","text":"<p>The data in the WebSocket data frames may be compressed using zlib. In order to enable compression, the client must set the <code>useCompression</code> field in the login command to true. If compression is enabled during login, all messages sent and received after login completion must be binary data frames, in which the payload data (i.e., command request/response) is zlib-compressed.</p>"},{"location":"WebsocketAPIV3/#heartbeatfeedback-messages","title":"Heartbeat/Feedback messages","text":"<p>The <code>feedbackInterval</code> session attribute specifies how often (in seconds) unidirectional heartbeat/feedback messages are sent to the client during query execution. These messages are sent using Pong WebSocket control frames (see RFC 6455), and thus a response is not expected.</p> <p>The client may send Ping WebSocket control frames (see RFC 6455) to Exasol, for example, as client-initiated keepalives. Exasol will respond to a Ping frame with a Pong response.</p> <p>Exasol will not send Ping frames to the client.</p>"},{"location":"WebsocketAPIV3/#subconnections","title":"Subconnections","text":""},{"location":"WebsocketAPIV3/#introduction","title":"Introduction","text":"<p>Subconnections are additional connections to Exasol cluster nodes which can be created by the client. There are two main reasons to create and use subconnections. 1. Read a result set in parallel: fetch can be called in parallel by each of the subconnections to read a result set. 2. <code>INSERT</code> data in parallel: executePreparedStatement can be called in parallel on each of the subconnections to <code>INSERT</code> various data. Please note that the same prepared statement (see createPreparedStatement) must be executed on all subconnections.</p> <p>\u2139\ufe0f Here, parallel refers to the node-wise reading/inserting of data. For example, if there is a subconnection for each node (i.e., the number of subconnections equals the number of cluster nodes), then each subconnection will read/insert data locally from/into its node.</p> <p>Fetching a result set from Exasol can be done easily using the main connection. In this scenario, the Exasol cluster nodes will automatically send their data to the node which is connected to the client. This node then sends the combined data as a single result set. Thus, the client does not need to be aware of any data sharing/communication among the Exasol cluster nodes.</p> <p>However, for performance-critical scenarios, a significant performance gain can be acheived by using subconnections to fetch/insert data directly from/into multiple Exasol cluster nodes in parallel. Thus, instead of all the data going through the single main connection, the data can flow through multiple subconnections from/to different Exasol nodes in parallel.</p> <p>Please note that subconnections are only useful for multi-node Exasol clusters. With a single-node Exasol instance, the subconnection would basically be a duplicate of the main connection.</p>"},{"location":"WebsocketAPIV3/#how-to-create-and-use-subconnections","title":"How to create and use subconnections","text":"<p>Subconnections are created using the enterParallel command. The number of requested subconnections can be specified by the user, and the number of subconnections actually opened is given in the enterParallel response. Please note that the maximum number of subconnections is equal to the number of nodes in the Exasol cluster. For example, if the user has an eight-node cluster and requests 1,000 subconnections, only eight subconnections will be opened. As a general rule, the number of subconnections should usually be equal to the number of nodes in the Exasol cluster, which ensures one subconnection per node. After the subconnections have been created, the subLogin or subLoginToken command should be used to login to each subconnection. Note: Failing to login to all subconnections will cause the login to hang. After this, they are ready for use.</p> <p>\u26a0\ufe0f Please note: autocommit should be disabled before opening any subconnections. After closing the subconnections, it can be re-enabled.</p> <p>Any command can be executed on subconnections; however, there is a significant difference in how they can be executed. The only two commands which can be executed ansynchronously on subconnections (i.e., not executed on all subconnections at the same time) are fetch and executePreparedStatement. All other commands are synchronous, meaning the same command must be executed on all subconnections at the same time. For example, if the execute command is not called on all subconnections, the call will hang and eventually fail because of a time out.</p> <p>\u26a0\ufe0f Please note: different statements cannot be run in parallel using subconnections.</p> <p>After a subconnection is no longer needed, the disconnect command should be called and the WebSocket for it closed as normal. Please note that subconnections can be reused for multiple statements.</p>"},{"location":"WebsocketAPIV3/#example","title":"Example","text":"<p>The following is an example of how to create, use, and close subconnections to fetch a result set from an executed prepared statement. If subconnections have already been created or are needed afterwards, the enterParallel, subLogin, and disconnect commands may be ignored.</p> <ol> <li>On main connection:</li> <li> <p>Create subconnections (enterParallel)</p> </li> <li> <p>On subconnections:</p> </li> <li> <p>Login to subconnection (subLogin)</p> </li> <li> <p>On main connection:</p> </li> <li> <p>Execute prepared statement (executePreparedStatement)</p> </li> <li> <p>On subconnections:</p> </li> <li>Get result set offset (getOffset)</li> <li>Fetch result set data using the offset (fetch)</li> <li>Close result set (closeResultSet)</li> <li> <p>Disconnect (disconnect)</p> </li> <li> <p>On main connection:</p> </li> <li>Close result set (closeResultSet)</li> </ol>"},{"location":"commands/abortQueryV1/","title":"abortQueryV1","text":""},{"location":"commands/abortQueryV1/#abortquery-aborts-a-running-query","title":"abortQuery: Aborts a running query","text":"<p>This command aborts a running query. It does not have a response.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"abortQuery\"</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"abortQuery\"\n}\n</code></pre></p>"},{"location":"commands/closePreparedStatementV1/","title":"closePreparedStatementV1","text":""},{"location":"commands/closePreparedStatementV1/#closepreparedstatement-closes-a-prepared-statement","title":"closePreparedStatement: Closes a prepared statement","text":"<p>This command closes a prepared statement which has already been created.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"closePreparedStatement\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>statementHandle (number) =&gt; prepared statement handle</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"closePreparedStatement\",\n\"attributes\": {\n// as defined separately\n},\n\"statementHandle\": &lt;number&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object) =&gt; attributes set for the connection (see Attributes)</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/closeResultSetV1/","title":"closeResultSetV1","text":""},{"location":"commands/closeResultSetV1/#closeresultset-closes-a-result-set","title":"closeResultSet: Closes a result set","text":"<p>This command closes result sets.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"closeResultSet\"`</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>resultSetHandles (number[]) =&gt; array of result set handles</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"closeResultSet\",\n\"attributes\": {\n// as defined separately\n},\n\"resultSetHandles\": [ &lt;number&gt; ]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;, // Exception text\n\"sqlCode\": &lt;string&gt; // Five-character exception code if known, otherwise \"00000\"\n}\n}\n</code></pre></p>"},{"location":"commands/createPreparedStatementV1/","title":"createPreparedStatementV1","text":""},{"location":"commands/createPreparedStatementV1/#createpreparedstatement-creates-a-prepared-statement","title":"createPreparedStatement: Creates a prepared statement","text":"<p>This command creates a prepared statement.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"createPreparedStatement\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>sqlText (string) =&gt; SQL statement</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"createPreparedStatement\",\n\"attributes\": {\n// as defined separately\n},\n\"sqlText\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>statementHandle (number) =&gt; prepared statement handle</li> <li>parameterData (object, optional) =&gt; prepared statement parameter information</li> <li>numColumns (number) =&gt; number of columns</li> <li>columns (object[]) =&gt; array of column metadata objects<ul> <li>name (string) =&gt; column name: always \"\" as named parameters are not supported</li> <li>dataType (object) =&gt; column metadata</li> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects<ul> <li>resultType (string) =&gt; type of result: \"resultSet\" or \"rowCount\"</li> <li>rowCount (number, optional) =&gt; present if resultType is \"rowCount\", number of rows</li> <li>resultSet (object, optional) =&gt; present if resultType is \"resultSet\", result set</li> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects<ul> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata</li> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// if status is \"ok\"\n\"responseData\": {\n\"statementHandle\": &lt;number&gt;,\n\"parameterData\": {\n\"numColumns\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ]\n},\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": &lt;\"resultSet\" | \"rowCount\"&gt;,\n// if type is \"rowCount\"\n\"rowCount\": &lt;number&gt;,\n// if type is \"resultSet\"\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ]\n}\n} ]\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/disconnectV1/","title":"disconnectV1","text":""},{"location":"commands/disconnectV1/#disconnect-closes-a-connection-to-exasol","title":"disconnect: Closes a connection to Exasol","text":"<p>This command closes the connection between the client and Exasol. After the connection is closed, it cannot be used for further interaction with Exasol.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"disconnect\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"disconnect\",\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Reponse JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/enterParallelV1/","title":"enterParallelV1","text":""},{"location":"commands/enterParallelV1/#enterparallel-opens-subconnections-for-parallel-execution","title":"enterParallel: Opens subconnections for parallel execution","text":"<p>This command opens subconnections, which are additional connections to other nodes in the cluster, for the purpose of parallel execution. If the requested number of subconnections is 0, all open subconnections are closed.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"enterParallel\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see see Attributes)</li> <li>hostIp (string) =&gt; IP address of the Exasol host to which the client is currently connected (i.e., the Exasol host used to create the connection; e.g., ws://\\&lt;hostIp&gt;:8563)</li> <li>numRequestedConnections (number) =&gt; number of subconnections to open. If 0, all open subconnections are closed.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"enterParallel\",\n\"attributes\": {\n// as defined separately\n},\n\"hostIp\": &lt;string&gt;,\n\"numRequestedConnections\": &lt;number&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numOpenConnections (number) =&gt; number of subconnections actually opened</li> <li>token (number) =&gt; token required for the login of subconnections</li> <li>nodes (string[]) =&gt; IP addresses and ports of the nodes, to which subconnections may be established</li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// in case of \"ok\"\n\"responseData\": {\n\"numOpenConnections\": &lt;number&gt;,\n\"token\": &lt;number&gt;,\n\"nodes\": [\n&lt;string&gt;\n]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/executeBatchV1/","title":"executeBatchV1","text":""},{"location":"commands/executeBatchV1/#executebatch-executes-multiple-sql-statements-as-a-batch","title":"executeBatch: Executes multiple SQL statements as a batch","text":"<p>This command executes multiple SQL statements sequentially as a batch.</p> <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"executeBatch\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>sqlTexts (string[]) =&gt; array of SQL statement to execute</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"executeBatch\",\n\"attributes\": {\n// as defined separately\n},\n\"sqlTexts\": [\n&lt;string&gt;\n]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\" or \"rowCount\"</li> <li>rowCount (number, optional) =&gt; present if resultType is \"rowCount\", number of rows</li> <li>resultSet (object, optional) =&gt; present if resultType is \"resultSet\", result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": &lt;\"resultSet\" | \"rowCount\"&gt;,\n// if type is \"rowCount\"\n\"rowCount\": &lt;number&gt;,\n// if type is \"resultSet\"\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/executePreparedStatementV1/","title":"executePreparedStatementV1","text":""},{"location":"commands/executePreparedStatementV1/#executepreparedstatement-executes-a-prepared-statement","title":"executePreparedStatement: Executes a prepared statement","text":"<p>This command executes a prepared statement which has already been created.</p> <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"executePreparedStatement\"</li> <li>attributes (object, optional) =&gt;   attributes to set for the connection (see Attributes)</li> <li>statementHandle (number) =&gt; prepared statement handle</li> <li>numColumns (number) =&gt; number of columns in data</li> <li>numRows (number) =&gt; number of rows in data</li> <li>columns (object[], optional) =&gt; array of column metadata objects<ul> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata</li> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> <li>data (array[], optional) =&gt; array containing the data for the prepared statement in column-major order</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"executePreparedStatement\",\n\"attributes\": {\n// as defined separately\n},\n\"statementHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;boolean&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\" or \"rowCount\"</li> <li>rowCount (number, optional) =&gt; present if resultType is \"rowCount\", number of rows</li> <li>resultSet (object, optional) =&gt; present if resultType is \"resultSet\", result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": &lt;\"resultSet\" | \"rowCount\"&gt;,\n// if type is \"rowCount\"\n\"rowCount\": &lt;number&gt;,\n// if type is \"resultSet\"\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/executeV1/","title":"executeV1","text":""},{"location":"commands/executeV1/#execute-executes-an-sql-statement","title":"execute: Executes an SQL statement","text":"<p>This command executes an SQL statement.</p> <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"execute\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>sqlText (string) =&gt; SQL statement to execute</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"execute\",\n\"attributes\": {\n// as defined separately\n},\n\"sqlText\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\" or \"rowCount\"</li> <li>rowCount (number, optional) =&gt; present if resultType is \"rowCount\", number of rows</li> <li>resultSet (object, optional) =&gt; present if resultType is \"resultSet\", result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": &lt;\"resultSet\" | \"rowCount\"&gt;,\n// if type is \"rowCount\"\n\"rowCount\": &lt;number&gt;,\n// if type is \"resultSet\"\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/fetchV1/","title":"fetchV1","text":""},{"location":"commands/fetchV1/#fetch-retrieves-data-from-a-result-set","title":"fetch: Retrieves data from a result set","text":"<p>This command retrieves data from a result set.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"fetch\"</li> <li>attributes (object, optional) =&gt;  attributes to set for the connection (see Attributes)</li> <li>resultSetHandle (number) =&gt; result set handle</li> <li>startPosition (number) =&gt; row offset (0-based) from which to begin data retrieval</li> <li>numBytes (number) =&gt; number of bytes to retrieve (max: 64MB)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"fetch\",\n\"attributes\": {\n// as defined separately\n},\n\"resultSetHandle\": &lt;number&gt;,\n\"startPosition\": &lt;number&gt;,\n\"numBytes\": &lt;number&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numRows (number) =&gt; number of rows fetched from the result set</li> <li>data (array[]) =&gt; object containing the data in column-major order</li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// in case of \"ok\"\n\"responseData\": {\n\"numRows\": &lt;number&gt;,\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getAttributesV1/","title":"getAttributesV1","text":""},{"location":"commands/getAttributesV1/#getattributes-gets-the-session-attribute-values","title":"getAttributes: Gets the session attribute values","text":"<p>This command retrieves the session attribute values.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getAttributes\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> </ul> <p>JSON format <pre><code> {\n\"command\": \"getAttributes\",\n\"attributes\": {\n// as defined separately\n},\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>exception(object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Reponse JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getColumnPrivilegesV2/","title":"getColumnPrivilegesV2","text":""},{"location":"commands/getColumnPrivilegesV2/#getcolumnprivileges-gets-the-column-privilege-descriptions","title":"getColumnPrivileges: Gets the column privilege descriptions","text":"<p>This command gets the specified column privilege descriptions in the database.</p> <p>Result set columns: Ordered by <code>COLUMN</code>, <code>NAME</code>, <code>GRANTOR</code>, <code>GRANTEE</code>.</p> Name Data Type Description SCHEMA string schema name TABLE string table name COLUMN string column name NAME string privilege name GRANTOR string privilege grantor GRANTEE string privilege grantee OWNER string column owner <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getColumnPrivileges\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>table (string, optional) =&gt; table name. <code>\"\"</code> means no table, <code>null</code> means all tables.</li> <li>column (string, optional) =&gt; column name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no column, <code>null</code> means all columns.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getColumnPrivileges\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"table\": &lt;string&gt;,\n\"column\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getColumnsV2/","title":"getColumnsV2","text":""},{"location":"commands/getColumnsV2/#getcolumns-gets-the-column-descriptions","title":"getColumns: Gets the column descriptions","text":"<p>This command gets the specified columns descriptions in the database.</p> <p>Result set columns: Ordered by <code>SCHEMA</code>, <code>TABLE</code>, <code>ORDINAL_POSITION</code>.</p> Name Data Type Description SCHEMA string schema name TABLE string table name NAME string column name TABLE_TYPE string table type (supported values are \"SYSTEM TABLE\", \"TABLE\", \"VIEW\") TYPE string data type TYPE_ID number data type ID MAXSIZE number maximum number of characters for strings NUM_PREC number precision for numeric values NUM_SCALE number scale for numeric values ORDINAL_POSITION number column position in the table (beginning with 1) IS_VIRTUAL boolean is part of a virtual table IS_NULLABLE boolean are NULL values allowed (value is NULL for views) IS_DISTRIBUTION_KEY boolean column is part of the distribution key PARTITION_KEY_ORDINAL_POSITION number column position (beginning with 1) in the table's composite partition key, NULL for columns which are not part of it DEFAULT string default value IS_IDENTITY boolean has the identity attribute OWNER string owner name COMMENT string column comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getColumns\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>table (string, optional) =&gt; table name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no table, <code>null</code> means all tables.</li> <li>column (string, optional) =&gt; column name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no column, <code>null</code> means all columns.</li> <li>tableTypes (string[], optional) =&gt; array of table types (supported values are \"SYSTEM TABLE\", \"TABLE\", \"VIEW\"). <code>null</code> means all table types.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getColumns\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"table\": &lt;string&gt;,\n\"column\": &lt;string&gt;,\n\"tableTypes\": [\n&lt;string&gt;\n]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getConnectionsV2/","title":"getConnectionsV2","text":""},{"location":"commands/getConnectionsV2/#getconnections-gets-the-connections","title":"getConnections: Gets the connections","text":"<p>This command gets the specified connections in the database.</p> <p>Result set columns: Ordered by <code>NAME</code>.</p> Name Data Type Description NAME string connection name CREATED string when the connection was created COMMENT string connection comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getConnections\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>name (string, optional) =&gt; connection name. \"\" means no connection, null means all connections.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getConnections\",\n\"attributes\": {\n// as defined separately\n},\n\"name\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getFunctionsV2/","title":"getFunctionsV2","text":""},{"location":"commands/getFunctionsV2/#getfunctions-gets-the-function-descriptions","title":"getFunctions: Gets the function descriptions","text":"<p>This command gets the specified function descriptions in the database.</p> <p>Result set columns: Ordered by <code>SCHEMA</code>, <code>NAME</code>.</p> Name Data Type Description SCHEMA string schema name NAME string function name OWNER string owner name COMMENT string function comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getFunctions\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>function (string, optional) =&gt; function name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no function, <code>null</code> means all functions.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getFunctions\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"function\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getHostsV1/","title":"getHostsV1","text":""},{"location":"commands/getHostsV1/#gethosts-gets-the-hosts-in-a-cluster","title":"getHosts: Gets the hosts in a cluster","text":"<p>This command gets the number hosts and the IP address of each host in an Exasol cluster.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getHosts\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>hostIp (string) =&gt; IP address of the Exasol host to which the client is currently connected (i.e., the Exasol host used to create the connection; e.g., ws://\\&lt;hostIp&gt;:8563)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getHosts\",\n\"attributes\": {\n// as defined separately\n},\n\"hostIp\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numNodes (number) =&gt; number of nodes in the cluster</li> <li>nodes (string[]) =&gt; array of cluster node IP addresses</li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error      details</li> <li>sqlCode (string) =&gt; five-character exception code if known,      otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// in case of \"ok\"\n\"responseData\": {\n\"numNodes\": &lt;number&gt;,\n\"nodes\": [\n&lt;string&gt;\n]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getKeywordsV2/","title":"getKeywordsV2","text":""},{"location":"commands/getKeywordsV2/#getkeywords-gets-the-sql-keywords","title":"getKeywords: Gets the SQL keywords","text":"<p>This command gets all of the SQL keywords in the database.</p> <p>Result set columns: Ordered by <code>KEYWORD</code>.</p> Name Data Type Description KEYWORD string keyword RESERVED boolean is the keyword reserved (reserved keywords cannot be used as SQL identifiers) <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getKeywords\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getKeywords\",\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getOffsetV1/","title":"getOffsetV1","text":""},{"location":"commands/getOffsetV1/#getoffset-gets-the-row-offset-of-a-result-set","title":"getOffset: Gets the row offset of a result set","text":"<p>This command retrieves the row offset of the result set of this (sub)connection. This is the row number of the first row of the current (sub)connection's result set in the global result set.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getOffset\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>resultSetHandle (number) =&gt; open result set handle</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getOffset\",\n\"attributes\": {\n// as defined separately\n},\n\"resultSetHandle\": &lt;number&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>rowOffset (number) =&gt; row offset of connection's result set</li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// in case of \"ok\"\n\"responseData\": {\n\"rowOffset\": &lt;number&gt;\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getPrimaryKeysV2/","title":"getPrimaryKeysV2","text":""},{"location":"commands/getPrimaryKeysV2/#getprimarykeys-gets-the-primary-key-descriptions","title":"getPrimaryKeys: Gets the primary key descriptions","text":"<p>This command gets the specified primary key descriptions in the database.</p> <p>Result set columns: Ordered by <code>COLUMN_NAME</code>.</p> Name Data Type Description SCHEMA string schema name TABLE string table name NAME string primary key name OWNER string owner name ORDINAL_POSITION number column position in the table (beginning with 1) COLUMN_NAME string column name <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getPrimaryKeys\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>table (string, optional) =&gt; table name. <code>\"\"</code> means no table, <code>null</code> means all tables.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getPrimaryKeys\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"table\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getPropertiesV2/","title":"getPropertiesV2","text":""},{"location":"commands/getPropertiesV2/#getproperties-gets-the-database-properties","title":"getProperties: Gets the database properties","text":"<p>This command gets the specified properties of the database.</p> <p>Result set columns: Ordered by <code>NAME</code>.</p> Name Data Type Description NAME string property name VALUE string property value <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getProperties\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>name (string, optional) =&gt; property name. \"\" means no property, null means all properties.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getProperties\",\n\"attributes\": {\n// as defined separately\n},\n\"name\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getResultSetHeaderV1/","title":"getResultSetHeaderV1","text":""},{"location":"commands/getResultSetHeaderV1/#getresultsetheader-gets-a-result-set-header","title":"getResultSetHeader: Gets a result set header","text":"<p>This command retrieves a header (i.e., empty result set) which contains the metadata for an open result set.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getResultSetHeader\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>resultSetHandles (number[]) =&gt; array of open result set handles</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getResultSetHeader\",\n\"attributes\": {\n// as defined separately\n},\n\"resultSetHandles\": [\n&lt;number&gt;\n]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> <li>withLocalTimeZone (true | false, optional) =&gt; specifies if a timestamp has a local time zone</li> <li>fraction (number, optional) =&gt; fractional part of number</li> <li>srid (number, optional) =&gt; spatial reference system identifier</li> </ul> </li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;,\n\"withLocalTimeZone\": &lt;true | false&gt;,\n\"fraction\": &lt;number&gt;,\n\"srid\": &lt;number&gt;\n}\n} ]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getRolesV2/","title":"getRolesV2","text":""},{"location":"commands/getRolesV2/#getroles-gets-the-roles","title":"getRoles: Gets the roles","text":"<p>This command gets the specified roles in the database.</p> <p>Result set columns: Ordered by <code>NAME</code>.</p> Name Data Type Description NAME string role name CREATED string when the role was created CONSUMER_GROUP string role consumer group COMMENT string role comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getRoles\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>name (string, optional) =&gt; role name. \"\" means no role, null means all roles.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getRoles\",\n\"attributes\": {\n// as defined separately\n},\n\"name\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getSchemasV2/","title":"getSchemasV2","text":""},{"location":"commands/getSchemasV2/#getschemas-gets-the-schema-names","title":"getSchemas: Gets the schema names","text":"<p>This command gets the specified schema names in the database.</p> <p>Result set columns: Ordered by <code>NAME</code>.</p> Name Data Type Description NAME string schema name OWNER string owner name IS_VIRTUAL boolean schema is a virtual schema COMMENT string schema comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getSchemas\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getSchemas\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getScriptsV2/","title":"getScriptsV2","text":""},{"location":"commands/getScriptsV2/#getscripts-gets-the-script-descriptions","title":"getScripts: Gets the script descriptions","text":"<p>This command gets the specified script descriptions in the database.</p> <p>Result set columns: Ordered by <code>SCHEMA</code>, <code>NAME</code>.</p> Name Data Type Description SCHEMA string schema name NAME string script name OWNER string owner name TYPE string script type (PROCEDURE, ADAPTER or UDF) LANGUAGE string script language INPUT_TYPE string script input type (NULL, SCALAR or SET) RESULT_TYPE string script return type (ROWCOUNT, TABLE, RETURNS or EMITS) COMMENT string script comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getScripts\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>script (string, optional) =&gt; script name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no script, <code>null</code> means all scripts.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getScripts\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"script\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getTablePrivilegesV2/","title":"getTablePrivilegesV2","text":""},{"location":"commands/getTablePrivilegesV2/#gettableprivileges-gets-the-table-privilege-descriptions","title":"getTablePrivileges: Gets the table privilege descriptions","text":"<p>This command gets the specified table privilege descriptions in the database.</p> <p>Result set columns: Ordered by <code>SCHEMA</code>, <code>TABLE</code>, <code>NAME</code>, <code>GRANTOR</code>, <code>GRANTEE</code>.</p> Name Data Type Description SCHEMA string schema name TABLE string table name NAME string privilege name GRANTOR string privilege grantor GRANTEE string privilege grantee OWNER string table owner <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getTablePrivileges\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>table (string, optional) =&gt; table name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no table, <code>null</code> means all tables.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getTablePrivileges\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"table\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getTableTypesV2/","title":"getTableTypesV2","text":""},{"location":"commands/getTableTypesV2/#gettabletypes-gets-the-table-types","title":"getTableTypes: Gets the table types","text":"<p>This command gets the table types supported by the database.</p> <p>Result set columns: Ordered by <code>TABLE_TYPE</code>.</p> Name Data Type Description TABLE_TYPE string table type <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getTableTypes\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getTableTypes\",\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getTablesV2/","title":"getTablesV2","text":""},{"location":"commands/getTablesV2/#gettables-gets-the-table-descriptions","title":"getTables: Gets the table descriptions","text":"<p>This command gets the specified table descriptions in the database.</p> <p>Result set columns: Ordered by <code>TABLE_TYPE</code>, <code>SCHEMA</code>, <code>NAME</code>.</p> Name Data Type Description SCHEMA string schema name NAME string table name OWNER string owner name TABLE_TYPE string table type (supported values are \"SYSTEM TABLE\", \"TABLE\", \"VIEW\") IS_VIRTUAL boolean table is a virtual table HAS_DISTRIBUTION_KEY boolean table is explicitly distributed HAS_PARTITION_KEY boolean table is partitioned COMMENT string table comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getTables\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>schema (string, optional) =&gt; schema name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no schema, <code>null</code> means all schemas.</li> <li>table (string, optional) =&gt; table name search criteria in SQL <code>LIKE</code> format. <code>\"\"</code> means no table, <code>null</code> means all tables.</li> <li>tableTypes (string[], optional) =&gt; array of table types (supported values are \"SYSTEM TABLE\", \"TABLE\", \"VIEW\"). <code>null</code> means all table types.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getTables\",\n\"attributes\": {\n// as defined separately\n},\n\"schema\": &lt;string&gt;,\n\"table\": &lt;string&gt;,\n\"tableTypes\": [\n&lt;string&gt;\n]\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getTypeInfoV2/","title":"getTypeInfoV2","text":""},{"location":"commands/getTypeInfoV2/#gettypeinfo-gets-the-data-types","title":"getTypeInfo: Gets the data types","text":"<p>This command gets the data types supported by the database.</p> <p>Result set columns: Ordered by <code>TYPE_ID</code>.</p> Name Data Type Description NAME string type name TYPE_ID number data type ID PRECISION number precision LITERAL_PREFIX string literal quote prefix LITERAL_SUFFIX string literal quote suffix CREATE_PARAMS string type creation parameters IS_NULLABLE boolean NULL values are allowed CASE_SENSITIVE boolean is case sensitive SEARCHABLE number how the type can be used in a WHERE clause:0: cannot be searched1: can only be searched with WHERE .. LIKE2: cannot be searched with WHERE .. LIKE3: can be searched with any WHERE clause UNSIGNED_ATTRIBUTE boolean is unsigned FIXED_PREC_SCALE boolean has fixed representation AUTO_INCREMENT boolean is an automatically incremented type LOCAL_TYPE_NAME string localized type name MINIMUM_SCALE number minimum scale MAXIMUM_SCALE number maximum scale SQL_DATA_TYPE number SQL data type SQL_DATETIME_SUB number datetime and interval subtype NUM_PREC_RADIX number number base INTERVAL_PRECISION number interval precision <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getTypeInfo\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getTypeInfo\",\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/getUsersV2/","title":"getUsersV2","text":""},{"location":"commands/getUsersV2/#getusers-gets-the-users","title":"getUsers: Gets the users","text":"<p>This command gets the specified users in the database.</p> <p>Result set columns: Ordered by <code>NAME</code>.</p> Name Data Type Description NAME string user name CREATED string when the user was created CONSUMER_GROUP string user consumer group COMMENT string user comment <p>If the command returns a result set which has less than 1,000 rows of data, the data will be provided in the <code>data</code> field of <code>resultSet</code>. However if the command returns a result set which has 1,000 or more rows of data, a result set will be opened whose handle is returned in the <code>resultSetHandle</code> field of <code>resultSet</code>. Using this handle, the data from the result set can be retrieved using the <code>fetch</code> command. Once the result set is no longer needed, it should be closed using the <code>closeResultSet</code> command.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"getUsers\"</li> <li>attributes (object, optional) =&gt; attributes to set for the connection (see Attributes)</li> <li>name (string, optional) =&gt; user name. \"\" means no user, null means all users.</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"getUsers\",\n\"attributes\": {\n// as defined separately\n},\n\"name\": &lt;string&gt;\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt; attributes set for the connection (see Attributes)</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>numResults (number) =&gt; number of result objects</li> <li>results (object[]) =&gt; array of result objects</li> <li>resultType (string) =&gt; type of result: \"resultSet\"</li> <li>resultSet (object) =&gt; result set<ul> <li>resultSetHandle (number, optional) =&gt; result set handle</li> <li>numColumns (number) =&gt; number of columns in the result set</li> <li>numRows (number) =&gt; number of rows in the result set</li> <li>numRowsInMessage (number) =&gt; number of rows in the current message</li> <li>columns (object[]) =&gt; array of column metadata objects</li> <li>name (string) =&gt; column name</li> <li>dataType (object) =&gt; column metadata<ul> <li>type (string) =&gt; column data type</li> <li>precision (number, optional) =&gt; column precision</li> <li>scale (number, optional) =&gt; column scale</li> <li>size (number, optional) =&gt; maximum size in bytes of a column value</li> <li>characterSet (string, optional) =&gt; character encoding of a text column</li> </ul> </li> <li>data (array[], optional) =&gt; object containing the data in column-major order</li> </ul> </li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// in case of \"ok\"\n\"responseData\": {\n\"numResults\": &lt;number&gt;,\n\"results\": [ {\n\"resultType\": \"resultSet\",\n\"resultSet\": {\n\"resultSetHandle\": &lt;number&gt;,\n\"numColumns\": &lt;number&gt;,\n\"numRows\": &lt;number&gt;,\n\"numRowsInMessage\": &lt;number&gt;,\n\"columns\": [ {\n\"name\": &lt;string&gt;,\n\"dataType\": {\n\"type\": &lt;string&gt;,\n\"precision\": &lt;number&gt;,\n\"scale\": &lt;number&gt;,\n\"size\": &lt;number&gt;,\n\"characterSet\": &lt;string&gt;\n}\n} ],\n\"data\": [\n[\n&lt;string | number | true | false | null&gt;\n]\n]\n}\n} ]\n},\n// in case of \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/loginTokenV3/","title":"loginTokenV3","text":""},{"location":"commands/loginTokenV3/#logintoken-establishes-a-connection-to-exasol-using-an-openid-token","title":"loginToken: Establishes a connection to Exasol using an OpenID token","text":"<p>This command invokes the login process which establishes a connection between the client and Exasol. As long as the connection is open, the user can interact with Exasol using various commands.</p> <p> This command requires a TLS connection (i.e., <code>wss://...</code>).</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>loginToken</code> command including the requested protocol     version.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"loginToken\"</li> <li>protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 3)</li> </ul> <p>Request JSON format</p> <pre><code> {\n\"command\": \"loginToken\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre> </li> <li> <p>The server responds with either</p> <ul> <li>\"ok\", in which case the login process continues in step 3, or</li> <li>\"error\", in which case the login process is aborted.</li> </ul> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>exception (object, optional) =&gt; only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format</p> <pre><code>{\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre> </li> <li> <p>The client sends either an OpenID <code>accessToken</code> or a <code>refreshToken</code> and optionally    other client information.</p> <p>Request fields:</p> <ul> <li>accessToken (string, optional) =&gt; OpenID access token to use for the login process</li> <li>refreshToken (string, optional) =&gt; OpenID refresh token to use for the login process</li> <li>useCompression (boolean) =&gt; use compression for messages during the session (beginning after the login process is completed)</li> <li>sessionId (number, optional) =&gt; requested session ID</li> <li>clientName (string, optional) =&gt; client program name, (e.g., \"EXAplus\")</li> <li>driverName (string, optional) =&gt; driver name, (e.g., \"EXA Python\")</li> <li>clientOs (string, optional) =&gt; name and version of the client operating system</li> <li>clientOsUsername (string, optional) =&gt; client's operating system user name</li> <li>clientLanguage (string, optional) =&gt; language setting of the client system</li> <li>clientVersion (string, optional) =&gt; client version number</li> <li>clientRuntime (string, optional) =&gt; name and version of the client runtime</li> <li>attributes (object, optional) =&gt; array of attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format    <pre><code> {\n\"accessToken\": &lt;string&gt;,\n\"refreshToken\": &lt;string&gt;,\n\"useCompression\": &lt;boolean&gt;,\n\"sessionId\": &lt;number&gt;,\n\"clientName\": &lt;string&gt;,\n\"driverName\": &lt;string&gt;,\n\"clientOs\": &lt;string&gt;,\n\"clientOsUsername\": &lt;string&gt;,\n\"clientLanguage\": &lt;string&gt;,\n\"clientVersion\": &lt;string&gt;,\n\"clientRuntime\": &lt;string&gt;,\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> </li> <li> <p>The server uses either <code>accessToken</code> or <code>refreshToken</code> (see 3.) to authenticate the    user. If successful, the server replies with an \"ok\" response and a    connection is established. If authentication of the user fails, the    server sends an \"error\" response to the client indicating that the login    process failed and a connection could not be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"<ul> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> </ul> </li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"},{"location":"commands/loginV1/","title":"loginV1","text":""},{"location":"commands/loginV1/#login-establishes-a-connection-to-exasol","title":"login: Establishes a connection to Exasol","text":"<p>This command invokes the login process which establishes a connection between the client and Exasol. As long as the connection is open, the user can interact with Exasol using various commands.</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>login</code> command including the requested protocol     version.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"login\"</li> <li>protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 1)</li> </ul> <p>Request JSON format  <pre><code> {\n\"command\": \"login\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server returns a public key which is used to encode the    user's password. The public key can be obtained in one of two ways:</p> <ul> <li>importing the key using the <code>publicKeyPem</code> field, or</li> <li>constructing the key using the <code>publicKeyModulus</code> and <code>publicKeyExponent</code> fields.</li> </ul> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>publicKeyPem (string) =&gt; PEM-formatted, 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyModulus (string) =&gt; hexadecimal modulus of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyExponent (string) =&gt; hexadecimal exponent of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>exception (object, optional) =&gt; only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"publicKeyPem\": &lt;string&gt;,\n\"publicKeyModulus\": &lt;string&gt;,\n\"publicKeyExponent\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> <li> <p>The client sends the username, encrypted password, and optionally    other client information.</p> <p>Request fields:</p> <ul> <li>username (string) =&gt; Exasol user name to use for the login process</li> <li>password (string) =&gt; user's password, which is encrypted using publicKey (see 2.) and PKCS #1 v1.5 padding, encoded in Base64 format</li> <li>useCompression (boolean) =&gt; use compression for messages during the session (beginning after the login process is completed)</li> <li>sessionId (number, optional) =&gt; requested session ID</li> <li>clientName (string, optional) =&gt; client program name, (e.g., \"EXAplus\")</li> <li>driverName (string, optional) =&gt; driver name, (e.g., \"EXA Python\")</li> <li>clientOs (string, optional) =&gt; name and version of the client operating system</li> <li>clientOsUsername (string, optional) =&gt; client's operating system user name</li> <li>clientLanguage (string, optional) =&gt; language setting of the client system</li> <li>clientVersion (string, optional) =&gt; client version number</li> <li>clientRuntime (string, optional) =&gt; name and version of the client runtime</li> <li>attributes (object, optional) =&gt; array of attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format  <pre><code> {\n\"username\": &lt;string&gt;,\n\"password\": &lt;string&gt;,\n\"useCompression\": &lt;boolean&gt;,\n\"sessionId\": &lt;number&gt;,\n\"clientName\": &lt;string&gt;,\n\"driverName\": &lt;string&gt;,\n\"clientOs\": &lt;string&gt;,\n\"clientOsUsername\": &lt;string&gt;,\n\"clientLanguage\": &lt;string&gt;,\n\"clientVersion\": &lt;string&gt;,\n\"clientRuntime\": &lt;string&gt;,\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> </li> <li> <p>The server uses <code>username</code> and <code>password</code> (see 3.) to authenticate the    user. If successful, the server replies with an \"ok\" response and a    connection is established. If authentication of the user fails, the    server sends an \"error\" response to the client indicating that the login    process failed and a connection could not be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"},{"location":"commands/loginV3/","title":"loginV3","text":""},{"location":"commands/loginV3/#login-establishes-a-connection-to-exasol","title":"login: Establishes a connection to Exasol","text":"<p>This command invokes the login process which establishes a connection between the client and Exasol. As long as the connection is open, the user can interact with Exasol using various commands.</p> <p>\u2139\ufe0f A compatibility mode has been added to enable logins using OpenID refresh tokens if using loginToken is not possible. For details, see step 3.</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>login</code> command including the requested protocol     version.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"login\"</li> <li>protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 1)</li> </ul> <p>Request JSON format  <pre><code> {\n\"command\": \"login\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server returns a public key which is used to encode the    user's password. The public key can be obtained in one of two ways:</p> <ul> <li>importing the key using the <code>publicKeyPem</code> field, or</li> <li>constructing the key using the <code>publicKeyModulus</code> and <code>publicKeyExponent</code> fields.</li> </ul> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>publicKeyPem (string) =&gt; PEM-formatted, 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyModulus (string) =&gt; hexadecimal modulus of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyExponent (string) =&gt; hexadecimal exponent of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>exception (object, optional) =&gt; only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"publicKeyPem\": &lt;string&gt;,\n\"publicKeyModulus\": &lt;string&gt;,\n\"publicKeyExponent\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> <li> <p>The client sends the username, encrypted password or OpenID refresh token, and optionally    other client information.</p> <p>To use OpenID compatibility mode, substitute the OpenID refresh token for the password.</p> <p>Request fields:</p> <ul> <li>username (string) =&gt; Exasol user name to use for the login process</li> <li>password (string) =&gt; user's password or OpenID refresh token, which is encrypted using publicKey (see 2.) and PKCS #1 v1.5 padding, encoded in Base64 format</li> <li>useCompression (boolean) =&gt; use compression for messages during the session (beginning after the login process is completed)</li> <li>sessionId (number, optional) =&gt; requested session ID</li> <li>clientName (string, optional) =&gt; client program name, (e.g., \"EXAplus\")</li> <li>driverName (string, optional) =&gt; driver name, (e.g., \"EXA Python\")</li> <li>clientOs (string, optional) =&gt; name and version of the client operating system</li> <li>clientOsUsername (string, optional) =&gt; client's operating system user name</li> <li>clientLanguage (string, optional) =&gt; language setting of the client system</li> <li>clientVersion (string, optional) =&gt; client version number</li> <li>clientRuntime (string, optional) =&gt; name and version of the client runtime</li> <li>attributes (object, optional) =&gt; array of attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format  <pre><code> {\n\"username\": &lt;string&gt;,\n\"password\": &lt;string&gt;,\n\"useCompression\": &lt;boolean&gt;,\n\"sessionId\": &lt;number&gt;,\n\"clientName\": &lt;string&gt;,\n\"driverName\": &lt;string&gt;,\n\"clientOs\": &lt;string&gt;,\n\"clientOsUsername\": &lt;string&gt;,\n\"clientLanguage\": &lt;string&gt;,\n\"clientVersion\": &lt;string&gt;,\n\"clientRuntime\": &lt;string&gt;,\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> </li> <li> <p>The server uses <code>username</code> and <code>password</code> (see 3.) to authenticate the    user. If successful, the server replies with an \"ok\" response and a    connection is established. If authentication of the user fails, the    server sends an \"error\" response to the client indicating that the login    process failed and a connection could not be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"},{"location":"commands/setAttributesV1/","title":"setAttributesV1","text":""},{"location":"commands/setAttributesV1/#setattributes-sets-the-given-session-attribute-values","title":"setAttributes: Sets the given session attribute values","text":"<p>This command sets the specified session attribute values.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"setAttributes\"</li> <li>attributes (object, optional) =&gt;  attributes to set for the connection (see Attributes)</li> </ul> <p>Request JSON format <pre><code> {\n\"command\": \"setAttributes\",\n\"attributes\": {\n// as defined separately\n}\n}\n</code></pre></p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>attributes (object, optional) =&gt;  attributes set for the connection (see Attributes)</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"<ul> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> </li> </ul> <p>Response JSON format <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n\"attributes\": {\n// as defined separately\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p>"},{"location":"commands/subLoginTokenV3/","title":"subLoginTokenV3","text":""},{"location":"commands/subLoginTokenV3/#sublogintoken-establishes-a-subconnection-to-exasol-using-an-openid-token","title":"subLoginToken: Establishes a subconnection to Exasol using an OpenID token","text":"<p>This command invokes the login process, which establishes a subconnection between the client and Exasol. Using subconnections, the user can interact with Exasol in parallel using various commands.</p> <p> This command requires a TLS connection (i.e., <code>wss://...</code>).</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>subLoginToken</code> command including the requested protocol    version.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"subLoginToken\"</li> <li>protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 3)</li> </ul> <p>Request JSON format  <pre><code> {\n\"command\": \"subLoginToken\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server responds with either</p> <ul> <li>\"ok\", in which case the login process continues in step 3, or</li> <li>\"error\", in which case the login process is aborted.</li> </ul> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>exception (object, optional) =&gt; only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> <li> <p>The client sends either an OpenID <code>accessToken</code> or a <code>refreshToken</code> and optionally other client information.</p> <p>Request fields:</p> <ul> <li>accessToken (string, optional) =&gt; OpenID access token to use for the login process</li> <li>refreshToken (string, optional) =&gt; OpenID refresh token to use for the login process</li> <li>token (number) =&gt; token required for subconnection logins (see, EnterParallel)</li> </ul> <p>Request JSON format  <pre><code> {\n\"accessToken\": &lt;string&gt;,\n\"refreshToken\": &lt;string&gt;,\n\"token\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server uses either <code>accessToken</code> or <code>refreshToken</code> (see 3.) to authenticate the    user. If successful, the server replies with an    \"ok\" response and a subconnection is established. If authentication of    the user fails, the server sends an \"error\" response to the client    indicating that the login process failed and a subconnection could not    be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"},{"location":"commands/subLoginV1/","title":"subLoginV1","text":""},{"location":"commands/subLoginV1/#sublogin-establishes-a-subconnection-to-exasol","title":"subLogin: Establishes a subconnection to Exasol","text":"<p>This command invokes the login process, which establishes a subconnection between the client and Exasol. Using subconnections, the user can interact with Exasol in parallel using various commands.</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>subLogin</code> command including the requested protocol    version.</p> <p>Request fields:</p> <ul> <li>command (string) =&gt; command name: \"subLogin\"</li> <li>protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 1)</li> </ul> <p>Request JSON format  <pre><code> {\n\"command\": \"subLogin\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server returns a public key which is used to encode the    user's password. The public key can be obtained in one of two ways:</p> <ul> <li>importing the key using the <code>publicKeyPem</code> field, or</li> <li>constructing the key using the <code>publicKeyModulus</code> and <code>publicKeyExponent</code> fields.</li> </ul> <p>Response fields:  * status (string) =&gt; command status: \"ok\" or \"error\"  * responseData (object, optional) =&gt; only present if status is \"ok\"    * publicKeyPem (string) =&gt; PEM-formatted, 1024-bit RSA public key used to encode the user's password (see 3.)    * publicKeyModulus (string) =&gt; hexadecimal modulus of the 1024-bit RSA public key used to encode the user's password (see 3.)    * publicKeyExponent (string) =&gt; hexadecimal exponent of the 1024-bit RSA public key used to encode the user's password (see 3.)  * exception (object, optional) =&gt; only present if status is \"error\"    * text (string) =&gt; exception message which provides error details    * sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</p> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"publicKeyPem\": &lt;string&gt;,\n\"publicKeyModulus\": &lt;string&gt;,\n\"publicKeyExponent\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> <li> <p>The client sends the username, encrypted password, and token.</p> <p>Request fields:</p> <ul> <li>username (string) =&gt; Exasol user name to use for the login process</li> <li>password (string) =&gt; user's password, which is encrypted using publicKey (see 2.) and PKCS #1 v1.5 padding, encoded in Base64 format</li> <li>token (number) =&gt; token required for subconnection logins (see, EnterParallel)</li> </ul> <p>Request JSON format  <pre><code> {\n\"username\": &lt;string&gt;,\n\"password\": &lt;string&gt;,\n\"token\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server uses <code>username</code>, <code>password</code>, and <code>token</code> (see 3.) to    authenticate the user. If successful, the server replies with an    \"ok\" response and a subconnection is established. If authentication of    the user fails, the server sends an \"error\" response to the client    indicating that the login process failed and a subconnection could not    be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"},{"location":"commands/subLoginV3/","title":"subLoginV3","text":""},{"location":"commands/subLoginV3/#sublogin-establishes-a-subconnection-to-exasol","title":"subLogin: Establishes a subconnection to Exasol","text":"<p>This command invokes the login process, which establishes a subconnection between the client and Exasol. Using subconnections, the user can interact with Exasol in parallel using various commands.</p> <p>\u2139\ufe0f A compatibility mode has been added to enable logins using OpenID refresh tokens if using subLoginToken is not possible. For details, see step 3.</p> <p>The login process is composed of four steps:</p> <ol> <li> <p>The client sends the <code>subLogin</code> command including the requested protocol    version.</p> <p>Request fields:  * command (string) =&gt; command name: \"subLogin\"  * protocolVersion (number) =&gt; requested WebSocket protocol version, (e.g., 1)</p> <p>Request JSON format  <pre><code> {\n\"command\": \"subLogin\",\n\"protocolVersion\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server returns a public key which is used to encode the    user's password. The public key can be obtained in one of two ways:</p> <ul> <li>importing the key using the <code>publicKeyPem</code> field, or</li> <li>constructing the key using the <code>publicKeyModulus</code> and <code>publicKeyExponent</code> fields.</li> </ul> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>publicKeyPem (string) =&gt; PEM-formatted, 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyModulus (string) =&gt; hexadecimal modulus of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>publicKeyExponent (string) =&gt; hexadecimal exponent of the 1024-bit RSA public key used to encode the user's password (see 3.)</li> <li>exception (object, optional) =&gt; only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"publicKeyPem\": &lt;string&gt;,\n\"publicKeyModulus\": &lt;string&gt;,\n\"publicKeyExponent\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> <li> <p>The client sends the username, encrypted password or OpenID refresh token, and token.</p> <p>To use OpenID compatibility mode, substitute the OpenID refresh token for the password.</p> <p>Request fields:</p> <ul> <li>username (string) =&gt; Exasol user name to use for the login process</li> <li>password (string) =&gt; user's password or OpenID refresh token, which is encrypted using publicKey (see 2.) and PKCS #1 v1.5 padding, encoded in Base64 format</li> <li>token (number) =&gt; token required for subconnection logins (see, EnterParallel)</li> </ul> <p>Request JSON format  <pre><code> {\n\"username\": &lt;string&gt;,\n\"password\": &lt;string&gt;,\n\"token\": &lt;number&gt;\n}\n</code></pre></p> </li> <li> <p>The server uses <code>username</code>, <code>password</code>, and <code>token</code> (see 3.) to    authenticate the user. If successful, the server replies with an    \"ok\" response and a subconnection is established. If authentication of    the user fails, the server sends an \"error\" response to the client    indicating that the login process failed and a subconnection could not    be established.</p> <p>Response fields:</p> <ul> <li>status (string) =&gt; command status: \"ok\" or \"error\"</li> <li>responseData (object, optional) =&gt; only present if status is \"ok\"</li> <li>sessionId (number) =&gt; current session ID</li> <li>protocolVersion (number) =&gt; WebSocket protocol version of the connection (e.g., 1)</li> <li>releaseVersion (string) =&gt; Exasol version (e.g. \"6.0.0\")</li> <li>databaseName (string) =&gt; database name (e.g., \"productionDB1\")</li> <li>productName (string) =&gt; Exasol product name: \"EXASolution\"</li> <li>maxDataMessageSize (number) =&gt; maximum size of a data message in bytes</li> <li>maxIdentifierLength (number) =&gt; maximum length of identifiers</li> <li>maxVarcharLength (number) =&gt;  maximum length of VARCHAR values</li> <li>identifierQuoteString (string) =&gt; value of the identifier quote string (e.g., \"'\")</li> <li>timeZone (string) =&gt; name of the session time zone</li> <li>timeZoneBehavior (string) =&gt; value of the session option \"TIME_ZONE_BEHAVIOR\"</li> <li>exception (object, optional) =&gt;  only present if status is \"error\"</li> <li>text (string) =&gt; exception message which provides error details</li> <li>sqlCode (string) =&gt; five-character exception code if known, otherwise \"00000\"</li> </ul> <p>Response JSON format  <pre><code> {\n\"status\": &lt;\"ok\" | \"error\"&gt;,\n// if status is \"ok\"\n\"responseData\": {\n\"sessionId\": &lt;number&gt;,\n\"protocolVersion\": &lt;number&gt;,\n\"releaseVersion\": &lt;string&gt;,\n\"databaseName\": &lt;string&gt;,\n\"productName\": &lt;string&gt;,\n\"maxDataMessageSize\": &lt;number&gt;,\n\"maxIdentifierLength\": &lt;number&gt;,\n\"maxVarcharLength\": &lt;number&gt;,\n\"identifierQuoteString\": &lt;string&gt;,\n\"timeZone\": &lt;string&gt;,\n\"timeZoneBehavior\": &lt;string&gt;\n},\n// if status is \"error\"\n\"exception\": {\n\"text\": &lt;string&gt;,\n\"sqlCode\": &lt;string&gt;\n}\n}\n</code></pre></p> </li> </ol>"}]}